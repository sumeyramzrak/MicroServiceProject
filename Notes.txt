* Öncelikle powershell üzerinden bir solution oluþturduk 
	- Proje oluþturulacak path e git
		cd <Path>
	- Proje klasörü oluþtur.
		mkdir E-SourcingMicroService
	- Solution ekle
		dotnet new sln
	- Webapi projesi ekle
		dotnet new webapi -o ESourcing.Products
	- WebApi ye sln ekle
		dotnet sln add ESourcing.Products
 
* Microservis oluþturduk bu oluþturduðumuz microservis birden fazla olacak. Bu servisler apigateway ile sonuçlarýný webapp e getirecek. Web appde de uý katmanýnda sonuçlar gösterilecek. 

* Docker üzerinden mongodb pull edildi.
	-docker pull mongo
	-docker run -d -p 27017:27017 --name sourcingdb mongo

* Appsetting.json dosyasýnda database baðlantý bilgileri eklendi.
* Db baðlantý bilgilerini kullanabilmemiz için setting klasörü altýnda IProductDatabaseSettings,ProductDatabaseSettings oluþturuldu.
* MongoDb bilgilerini eriþebilmek için Program.cs dosyasýnda configuration eklendi.

---------------------------DOCKERIZE---------------------------
!!docker composeun bulunduðu pathde çalýþtýrýlacak cmdde !!
docker-compose -f docker-compose.yml -f docker-compose.override.yml up -d 
docker-compose up --build -d :  her þeyi build edip projeyi öyle oluþturur.
docker-compose down : containerlarý siler.

* Proje üzerine sað týklayýp Add --> Docker Support dediðimizde proje altýnda bir dockerfile oluþturuyor.
  - Eklenen docker file sadece ilgili projeyi kapsar. Bu projenin contenarize olmasýný saðlar.
  - Docker compose üzerinden ayaða kaldýrdýðmýzda bu docker file ýn bir anlamý olmayacaktýr.
  - Oluþturulan dockerfile 2 image üzerinden beslenir.
	1) Build için
	2) Runtimeda projeyi çalýþtýrmak için
  - Dockerfile projenin image oluþmasýndan sorumlu komutlarý barýndýrýr.
  - Docker compose için dockerfile da ne yazdýðýnýn bir önemi yok

* Docker-Volume
  # Image üzerinden bir container oluþturduðumuzda container üzerinde yapýlan deðiþiklikler container yaþarken devam edecektir fakat kill olduðunda deðiþiklikler yok olacaktýr. 
  # Volume sayesinde bir önceki kill olan containera kadar olan deðiþiklikler, datalar saklanýr.

*CONTAINERLARI AYAÐA KALDIRMA
  docker run --name some-mongo -p  27017:27017 -d mongo
  docker run --hostname my-rabbit --name some-rabbit -p 15672:15672 rabbitmq:3-management
  rabbitmq-plugins enable rabbitmq_management
  docker start some-rabbit

---------------------------RABBIT MQ---------------------------
 docker run -d --hostname my-rabbit --name some-rabbit -p 8080:15672 rabbitmq:3-management
 docker run -d --hostname my-rabbit --name some-rabbit -p 15672:15672 -p 5672-5672 rabbitmq:3-management //localhosta baðlanabilmesi için sonrasýnda silip bu þekilde oluþturduk.
container ayaða kalktýktan sonra http://localhost:15672/ adresi üzerinden kullanýcý adý:guest / password: guest olarak giriþ yapýp servisleri tooldan inceleyebiliriz.

---------------------------MIGRATION---------------------------
* package manager console aç
* default proje olarak dbcontextin bulunduðu orderin.ýnfrastructure ý ayarla.
* add-migration Initial komutunu çalýþtýr.
	- Infrastructure altýnda Migrations klasörü oluþturacak.
	- Klasör altýna bazý classlar ekledi.
*update-database komutu çalýþtýrýlarak migration dosyasýndaki deðþiklikler database eyansýtýlýr.


---------------------------API GATEWAY---------------------------
* Clientlarýn servislere ayrý ayrý rootlardan ulaþmasýný istemiyoruz ortak bir giriþ kapýsýna ihtiyacýmýz var bu sebeple api gateway design pattern kullanýyoruz.
* Ocelot Apinin Saðladýðý avantajlar
  - Routing: Clientdan gelen istekleri arka tarafta apiler üzerinde daðýtarak arka tarafta servisler arasý bir köprü oluþturabilmesi
  - Authentication&Authorization: Api gateway e gelen isteklerini auth olduktan sonra servislere ulaþabilmesini saðlarýz. Bu patterni kullanmazsak her servis için ayrý ayrý auth yapýsý kurmamýz gerekir.
  - Rate Limiting(DDOS): Arka arkaya n tane art niyetli istek olduðunda bu durumu handle etmemizi saðlar, uygulamanýn down olmasýný engeller.
  					   Ýlgili servise þu kadar zaman diliminde bu kadar istek gelsin gibi konfigurasyonlar yapabiliyoruz.
  - Caching: Gelen istekleri arka tarafta cevap almadan önce cacheinde bulunuyorsa cevabý kendi üzerinden saðlar.
  - Load Balancing: Uygulamanýn scaleoutunu yönetebilmemizi saðlar.
  - Circuit Breaker:Uygulamanýn response veremediði durumda arka arkaya devamlý istek alma durumu mantýklý deðil. 
					Response gelene kadar gelen istekleri tekrar clienta döndürerek servisin kendine gelebilmesi için zaman saðlar.
  - Request Aggregation: Arka tarafta n tane servise istek yaparak bir data toplamak istiyoruz.

  ---------------------------SQL SERVERI DOCKER ÜZERÝNDEN KURMA---------------------------

  docker run -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=Odb12345678" -p 1433:1433 --name WebAppDb -d mcr.microsoft.com/mssql/server:2022-latest

  ***migration yapýldý